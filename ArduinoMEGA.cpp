#include <Arduino.h>
#include <LiquidCrystal.h>
#include <Keypad.h>
#include <Servo.h>
//#include <Servo.h>

Servo porta;
LiquidCrystal lcd(22, 23, 27, 26, 25, 24);
#define portapin 53
#define piezzo 41
#define Red 46
#define Green 45
String code;
char *getPhoneNumber();
char getKey();
void porta_motor();
const int numRows = 4;       // Rows in keypad
const int numCols = 4;       // Columns in Tastatur
const int debounceTime = 50; // Time in milliseconds to stabilize key signal
// Keymap defines chars for each key
char keymap[numRows][numCols] =
    {
        {'1', '2', '3', 'A'},
        {'4', '5', '6', 'B'},
        {'7', '8', '9', 'C'},
        {'*', '0', '#', 'D'}};
// Arrays definition for the Arduino Pins
byte rowPins[numRows] = {11, 10, 9, 8};
byte colPins[numCols] = {7, 6, 5, 4};
char key;
char PhoneNmb[10], Code[5];
int pos_code = 0;
int pos_phonenmb = 0;
int code_tries = 0;
int portaaberta = 0;
Keypad customKeypad = Keypad(makeKeymap(keymap), rowPins, colPins, numRows, numCols);
char PhoneNumber[10] = "";
char chave[5] = "     ";
volatile bool callForDoor = false;
bool right_code;
void door_call();
void correctsound();
void incorrectsound();

void setup()
{
  pinMode(Red, OUTPUT);
  pinMode(Green, OUTPUT);
  lcd.begin(16, 2);
  pinMode(18, INPUT_PULLUP);
  lcd.clear();
  Serial.begin(9600); // Open Serial Port
  for (int row = 0; row < numRows; row++)
  {
    pinMode(rowPins[row], INPUT);     // Switch Pins for Rows as input
    digitalWrite(rowPins[row], HIGH); // Activate Pullups
  }
  for (int column = 0; column < numCols; column++)
  {
    pinMode(colPins[column], OUTPUT);    // Switch Pins for Columns as input
    digitalWrite(colPins[column], HIGH); // Columns are inactive
  }

  attachInterrupt(digitalPinToInterrupt(18), door_call, FALLING);
}

void loop()
{


  if(callForDoor)
  {
    correctsound();
    porta.attach(portapin);
    volatile int i;
    for (i = 0; i <= 90; i++)
    {
      porta.write(i);
      delay(10);
    }
    porta.detach();
    delay(5000);
    porta.attach(portapin);
    for (i; i >= 0; i--)
    {
      porta.write(i);
      delay(10);
    }
    porta.detach();

    callForDoor = false;
  }
  else
  {
    lcd.setCursor(0, 0);
  lcd.print("INSERT PHONE NMB:");
  key = customKeypad.getKey();
  if (key)
  {
    PhoneNmb[pos_phonenmb] = key;
    lcd.setCursor(pos_phonenmb, 1);
    lcd.print(key);
    pos_phonenmb++;
  }
  if (pos_phonenmb == 9 || key == '#') // complete number or pretend to erase
  {
    if (pos_phonenmb == 9) // complete number
    {
      delay(800);
      Serial.println(PhoneNmb);            // sends number to python
      code = Serial.readStringUntil('\n'); // receives random code from python
      if (code[0] == '$')                  // not existent number in database
      {
        lcd.clear();
        lcd.setCursor(0, 0);
        lcd.print("NOT EXIST");
        delay(2500);
      }

      else // existing number in database
      {
        lcd.clear();
        ;
        lcd.setCursor(0, 0);
        lcd.print("INSERT RECEIVED");
        lcd.setCursor(0, 1);
        lcd.print("CODE:");
        while (pos_code < 4) // while code aint complete
        {
          if (code_tries == 3)
          {
            code_tries = 0;
            pos_code = 0;
            break;
          }
          while (code_tries < 3)
          {
            key = customKeypad.getKey();
            if (key)
            {
              Code[pos_code] = key;
              lcd.setCursor(pos_code + 5, 1);
              lcd.print(key);
              pos_code++;
              if (pos_code == 4 || key == '#') // if code complete or wants to erase
              {
                if (key == '#') // wants to erase code
                {
                  pos_phonenmb = 0;
                  strcpy(Code, "    ");
                  lcd.clear();
                  pos_code = 0;
                  lcd.clear();
                  ;
                  lcd.setCursor(0, 0);
                  lcd.print("INSERT RECEIVED");
                  lcd.setCursor(0, 1);
                  lcd.print("CODE:");
                }
                else // code is complete
                {
                  delay(800);
                  for (int i = 0; i < 4; i++) // compares the code that was inputed with the one generated by python
                  {
                    if (code[i] != Code[i])
                    {
                      right_code = false;
                      break;
                    }
                    else
                      right_code = true;
                  }
                  if (right_code) // code is correct
                  {
                    lcd.clear();
                    lcd.setCursor(0, 0);
                    lcd.print("CODE IS CORRECT");
                    correctsound();
                    porta_motor();
                    code_tries = 0;
                    Serial.println(0);
                    break;
                  }
                  else // code is incorrect
                  {
                    lcd.clear();
                    ;
                    lcd.setCursor(0, 0);
                    lcd.print("CODE IS");
                    lcd.setCursor(0, 1);
                    lcd.print("INCORRECT");
                    incorrectsound();
                    delay(800);
                    code_tries++;
                    lcd.clear();
                    ;
                    lcd.setCursor(0, 0);
                    lcd.print("ATTEMPTS: ");
                    lcd.print(3 - code_tries);
                    lcd.setCursor(0, 1);
                    lcd.print("CODE:");
                    pos_code = 0;
                    if (code_tries == 3) // VER SE ISTO ESTA BOM
                    {
                      right_code = true;
                      pos_phonenmb = 0;
                      Serial.println(1);

                      break;
                    }
                  }
                }
              }
            }
          }
        }
        code_tries = 0;
        pos_code = 0;
      }
    }
    pos_phonenmb = 0;
    strcpy(PhoneNmb, "         ");
    lcd.clear();
  }

  }



  
}

// getKey() returns pushed key or 0 if no key was pushed
char getKey()
{
  char key = 0; // 0 means no key was pushed
  for (int column = 0; column < numCols; column++)
  {
    digitalWrite(colPins[column], LOW); // Activate column.
    for (int row = 0; row < numRows; row++)
    {
      // Test for all raws if key was pushed.
      if (digitalRead(rowPins[row]) == LOW)
      {
        // key pushed?
        // delay(debounceTime); // Stabilize signal
        while (digitalRead(rowPins[row]) == LOW)
          ;
        // Wait for key to be released
        key = keymap[row][column]; // Put char of pushed key in variable key
      }
    }
    digitalWrite(colPins[column], HIGH);
    // Activate column
  }
  if (key != 0)
  {
    return key;
  }
}

void door_call()
{
  callForDoor = true;
}


void porta_motor()
{
  porta.attach(portapin);
  int i;
  for (i = 0; i <= 90; i++)
  {
    porta.write(i);
    delay(10);
  }
  porta.detach();
  delay(5000);
  porta.attach(portapin);
  for (i; i >= 0; i--)
  {
    porta.write(i);
    delay(10);
  }
  porta.detach();
}

void correctsound()
{
  digitalWrite(Green, HIGH);
  tone(piezzo, 600);
  delay(400);
  tone(piezzo, 800);
  delay(400);
  noTone(piezzo);
  digitalWrite(Green, LOW);
}

void incorrectsound()
{
  digitalWrite(Red, HIGH);
  tone(piezzo, 300);
  delay(1000);
  noTone(piezzo);
  digitalWrite(Red, LOW);
}